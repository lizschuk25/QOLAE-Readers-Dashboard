// ==============================================
// READERS DASHBOARD - READER ROUTES
// ==============================================
// Purpose: NDA, Report Viewer, Corrections, Payment Tracking
// Author: Liz
// Date: 28th October 2025
// ==============================================

import pg from 'pg';
import { insertSignaturesIntoNDA, flattenNDA } from '../utils/insertSignaturesIntoReadersNDA.js';

const { Pool } = pg;

// Database connections
const readersDb = new Pool({
  connectionString: process.env.READERS_DATABASE_URL
});

const caseManagersDb = new Pool({
  connectionString: process.env.CASEMANAGERS_DATABASE_URL
});

// ==============================================
// AUTHENTICATION MIDDLEWARE
// ==============================================
async function authenticateReader(request, reply) {
  try {
    await request.jwtVerify();

    // Verify reader role
    if (request.user.role !== 'reader') {
      throw new Error('Unauthorized');
    }
  } catch (error) {
    reply.code(401).send({
      success: false,
      error: 'Authentication required'
    });
  }
}

export default async function readerRoutes(fastify, options) {

  // ==============================================
  // READERS DASHBOARD (Main Workspace)
  // ==============================================
  fastify.get('/readers-dashboard', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name, type } = request.user;

    try {
      // Get reader data
      const readerResult = await readersDb.query(
        `SELECT "readerPin", "readerName", "readerType", email, phone,
                "ndaSigned", "portalAccessStatus", "totalAssignmentsCompleted",
                "averageTurnaroundHours", "totalEarnings"
         FROM readers
         WHERE "readerPin" = $1`,
        [pin]
      );

      if (readerResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Reader not found' });
      }

      const reader = readerResult.rows[0];

      // Get active assignments
      const assignmentsResult = await readersDb.query(
        `SELECT "assignmentId", "assignmentNumber", "reportType",
                "assignedAt", deadline, "assignmentStatus", "paymentAmount"
         FROM "readerAssignments"
         WHERE "readerPin" = $1
         AND "assignmentStatus" IN ('pending', 'inProgress')
         ORDER BY deadline ASC`,
        [pin]
      );

      return reply.view('readers-dashboard.ejs', {
        reader,
        assignments: assignmentsResult.rows
      });

    } catch (error) {
      fastify.log.error('Error loading readers dashboard:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load dashboard' });
    }
  });

  // ==============================================
  // NDA REVIEW PAGE
  // ==============================================
  fastify.get('/nda-review', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name, type } = request.user;

    try {
      // Get reader data
      const readerResult = await readersDb.query(
        'SELECT "readerPin", "readerName", "ndaSigned" FROM readers WHERE "readerPin" = $1',
        [pin]
      );

      if (readerResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Reader not found' });
      }

      const reader = readerResult.rows[0];

      // Get current NDA version
      const ndaResult = await readersDb.query(
        'SELECT "versionNumber", "effectiveDate", "ndaContent" FROM "readerNdaVersions" WHERE "isCurrent" = TRUE'
      );

      return reply.view('nda-review.ejs', {
        reader,
        nda: ndaResult.rows[0]
      });

    } catch (error) {
      fastify.log.error('Error loading NDA review:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load NDA' });
    }
  });

  // ==============================================
  // SIGN NDA (API) - Complete Workflow
  // ==============================================
  fastify.post('/api/readers/sign-nda', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { readerSignature } = request.body;

    try {
      // Get current NDA version
      const ndaResult = await readersDb.query(
        'SELECT id, "versionNumber" FROM "readerNdaVersions" WHERE "isCurrent" = TRUE'
      );

      if (ndaResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'NDA version not found' });
      }

      const nda = ndaResult.rows[0];

      // Step 1: Insert signatures (Reader + Liz)
      // Note: NDA was already generated by HR Compliance during reader registration
      const signatureResult = await insertSignaturesIntoNDA(pin, {
        readerSignature: readerSignature,
        lizSignature: true // Liz's signature from file
      });

      if (!signatureResult.success) {
        throw new Error(`Signature insertion failed: ${signatureResult.error}`);
      }

      // Step 2: Flatten NDA (make non-editable)
      const flattenResult = await flattenNDA(pin);
      if (!flattenResult.success) {
        throw new Error(`Flattening failed: ${flattenResult.error}`);
      }

      // Step 3: Update reader - NDA signed
      await readersDb.query(
        `UPDATE readers
         SET "ndaSigned" = TRUE,
             "ndaSignedAt" = NOW(),
             "ndaVersionId" = $1,
             "portalAccessStatus" = 'active'
         WHERE "readerPin" = $2`,
        [nda.id, pin]
      );

      // Log activity
      await readersDb.query(
        `INSERT INTO "readerActivityLog" ("readerPin", "activityType", "activityDescription")
         VALUES ($1, $2, $3)`,
        [pin, 'ndaSigned', `Reader signed NDA version ${nda.versionNumber}`]
      );

      return reply.send({
        success: true,
        message: 'NDA signed successfully',
        redirectTo: '/readers-dashboard',
        ndaPath: flattenResult.outputPath
      });

    } catch (error) {
      fastify.log.error('Error signing NDA:', error);
      return reply.code(500).send({ success: false, error: 'Failed to sign NDA' });
    }
  });

  // ==============================================
  // REPORT VIEWER (In-Workspace Only - No Download)
  // ==============================================
  fastify.get('/report-viewer/:assignmentId', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { assignmentId } = request.params;

    try {
      // Get assignment details
      const assignmentResult = await readersDb.query(
        `SELECT "assignmentId", "assignmentNumber", "readerPin", "reportType",
                "assignmentStatus", "redactedReportPath", deadline
         FROM "readerAssignments"
         WHERE "assignmentId" = $1 AND "readerPin" = $2`,
        [assignmentId, pin]
      );

      if (assignmentResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Assignment not found' });
      }

      const assignment = assignmentResult.rows[0];

      // Check if assignment is accessible
      if (assignment.assignmentStatus === 'completed' || assignment.assignmentStatus === 'cancelled') {
        return reply.code(403).send({ success: false, error: 'This assignment is no longer accessible' });
      }

      return reply.view('report-viewer.ejs', {
        assignment,
        reader: { pin, name }
      });

    } catch (error) {
      fastify.log.error('Error loading report viewer:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load report' });
    }
  });

  // ==============================================
  // CORRECTIONS EDITOR (In-Workspace Only)
  // ==============================================
  fastify.get('/corrections-editor/:assignmentId', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { assignmentId } = request.params;

    try {
      // Get assignment details
      const assignmentResult = await readersDb.query(
        `SELECT "assignmentId", "assignmentNumber", "readerPin", "reportType",
                "assignmentStatus", "redactedReportPath", "correctionsContent",
                deadline
         FROM "readerAssignments"
         WHERE "assignmentId" = $1 AND "readerPin" = $2`,
        [assignmentId, pin]
      );

      if (assignmentResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Assignment not found' });
      }

      const assignment = assignmentResult.rows[0];

      return reply.view('corrections-editor.ejs', {
        assignment,
        reader: { pin, name }
      });

    } catch (error) {
      fastify.log.error('Error loading corrections editor:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load editor' });
    }
  });

  // ==============================================
  // SAVE CORRECTIONS (API)
  // ==============================================
  fastify.post('/api/readers/save-corrections', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { assignmentId, corrections } = request.body;

    try {
      // Update assignment with corrections
      await readersDb.query(
        `UPDATE "readerAssignments"
         SET "correctionsContent" = $1,
             "correctionsUpdatedAt" = NOW()
         WHERE "assignmentId" = $2 AND "readerPin" = $3`,
        [JSON.stringify(corrections), assignmentId, pin]
      );

      // Log activity
      await readersDb.query(
        `INSERT INTO "readerActivityLog" ("readerPin", "activityType", "activityDescription")
         VALUES ($1, $2, $3)`,
        [pin, 'correctionsSaved', `Reader saved corrections for assignment ${assignmentId}`]
      );

      return reply.send({
        success: true,
        message: 'Corrections saved successfully'
      });

    } catch (error) {
      fastify.log.error('Error saving corrections:', error);
      return reply.code(500).send({ success: false, error: 'Failed to save corrections' });
    }
  });

  // ==============================================
  // SUBMIT CORRECTIONS (API)
  // ==============================================
  fastify.post('/api/readers/submit-corrections', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { assignmentId } = request.body;

    try {
      // Update assignment status
      const result = await readersDb.query(
        `UPDATE "readerAssignments"
         SET "assignmentStatus" = 'completed',
             "correctionsSubmittedAt" = NOW(),
             "actualTurnaroundHours" = EXTRACT(EPOCH FROM (NOW() - "assignedAt")) / 3600
         WHERE "assignmentId" = $1 AND "readerPin" = $2
         RETURNING "paymentAmount"`,
        [assignmentId, pin]
      );

      if (result.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Assignment not found' });
      }

      // Update reader stats
      await readersDb.query(
        `UPDATE readers
         SET "totalAssignmentsCompleted" = "totalAssignmentsCompleted" + 1
         WHERE "readerPin" = $1`,
        [pin]
      );

      // Log activity
      await readersDb.query(
        `INSERT INTO "readerActivityLog" ("readerPin", "activityType", "activityDescription")
         VALUES ($1, $2, $3)`,
        [pin, 'correctionsSubmitted', `Reader submitted corrections for assignment ${assignmentId}`]
      );

      return reply.send({
        success: true,
        message: 'Corrections submitted successfully! Payment pending review.',
        paymentAmount: result.rows[0].paymentAmount
      });

    } catch (error) {
      fastify.log.error('Error submitting corrections:', error);
      return reply.code(500).send({ success: false, error: 'Failed to submit corrections' });
    }
  });

  // ==============================================
  // PAYMENT STATUS
  // ==============================================
  fastify.get('/payment-status', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;

    try {
      // Get payment history
      const paymentsResult = await readersDb.query(
        `SELECT "assignmentId", "assignmentNumber", "paymentAmount",
                "correctionsSubmittedAt", "correctionsApproved",
                "paymentApproved", "paymentApprovedAt", "paymentProcessedAt"
         FROM "readerAssignments"
         WHERE "readerPin" = $1
         AND "assignmentStatus" = 'completed'
         ORDER BY "correctionsSubmittedAt" DESC`,
        [pin]
      );

      // Get total earnings
      const earningsResult = await readersDb.query(
        'SELECT "totalEarnings" FROM readers WHERE "readerPin" = $1',
        [pin]
      );

      return reply.view('payment-status.ejs', {
        reader: { pin, name, totalEarnings: earningsResult.rows[0].totalEarnings },
        payments: paymentsResult.rows
      });

    } catch (error) {
      fastify.log.error('Error loading payment status:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load payment status' });
    }
  });

  // ==============================================
  // PAYMENT PROCESSING ROUTES
  // ==============================================
  // Author: Liz
  // Date: October 28, 2025
  // Purpose: Payment modal, status API, history, support
  // ==============================================

  /**
   * ROUTE 1: RENDER PAYMENT PROCESSING MODAL
   * GET /payment-processing?assignmentId=xxx
   */
  fastify.get('/payment-processing', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    try {
      const { assignmentId } = request.query;
      const { pin } = request.user;

      if (!assignmentId) {
        return reply.code(400).send({ error: 'Assignment ID is required' });
      }

      // Get payment data from qolae_readers
      const paymentQuery = `
        SELECT 
          ra.id as "assignmentId",
          ra."readerPin",
          ra."paymentStatus",
          ra."paymentAmount",
          ra."paymentReference",
          ra."paymentApprovedAt",
          ra."paymentProcessedAt",
          ra."reportAssignedAt" as "assignedAt",
          ra."correctionsSubmittedAt",
          r."readerName",
          r.email as "readerEmail",
          r."paymentRate",
          r."readerType"
        FROM "readerAssignments" ra
        INNER JOIN readers r ON ra."readerPin" = r."readerPin"
        WHERE ra.id = $1 AND ra."readerPin" = $2
      `;

      const result = await readersDb.query(paymentQuery, [assignmentId, pin]);

      if (result.rows.length === 0) {
        return reply.code(404).send({ error: 'Payment record not found' });
      }

      const paymentData = result.rows[0];

      // Get banking details from qolae_hrcompliance (via separate connection)
      // NOTE: For now, we'll handle this separately. Banking details should be
      // fetched from HR Compliance database when needed for actual payment processing.
      
      // Build timeline based on payment status
      const timeline = buildTimeline(
        paymentData.paymentStatus,
        paymentData.assignedAt,
        paymentData.paymentApprovedAt,
        paymentData.paymentProcessedAt
      );

      // Determine reader type
      const readerType = paymentData.readerType === 'firstReader' ? 'first' : 'second';

      // Render EJS template
      return reply.view('paymentProcessing.ejs', {
        // Assignment info
        assignmentId: paymentData.assignmentId,
        readerPin: paymentData.readerPin,
        
        // Reader info
        readerName: paymentData.readerName,
        readerEmail: paymentData.readerEmail,
        readerType: readerType,
        
        // Payment status & amount
        paymentStatus: paymentData.paymentStatus || 'pending',
        paymentAmount: paymentData.paymentAmount || paymentData.paymentRate,
        paymentReference: paymentData.paymentReference || 'N/A',
        
        // Timeline dates
        assignedAt: paymentData.assignedAt,
        correctionsSubmittedAt: paymentData.correctionsSubmittedAt,
        paymentApprovedAt: paymentData.paymentApprovedAt,
        paymentProcessedAt: paymentData.paymentProcessedAt,
        
        // Timeline status
        timeline: timeline,
        
        // Placeholder banking details (will be fetched from HR Compliance when needed)
        bankName: 'Not loaded',
        accountHolderName: 'Not loaded',
        lastFourDigits: '****',
        sortCode: 'N/A',
        accountType: 'unknown',
        paymentDetailsVerified: false
      });

    } catch (error) {
      fastify.log.error('Error rendering payment processing modal:', error);
      return reply.code(500).send({ error: 'Internal server error' });
    }
  });

  /**
   * ROUTE 2: GET PAYMENT STATUS (API - FOR AUTO-REFRESH)
   * GET /api/readers/payment/status/:assignmentId
   */
  fastify.get('/api/readers/payment/status/:assignmentId', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    try {
      const { assignmentId } = request.params;
      const { pin } = request.user;

      const statusQuery = `
        SELECT 
          "paymentStatus",
          "paymentAmount",
          "paymentReference",
          "paymentApprovedAt",
          "paymentProcessedAt"
        FROM "readerAssignments"
        WHERE id = $1 AND "readerPin" = $2
      `;

      const result = await readersDb.query(statusQuery, [assignmentId, pin]);

      if (result.rows.length === 0) {
        return reply.code(404).send({ error: 'Assignment not found' });
      }

      return reply.send({
        paymentStatus: result.rows[0].paymentStatus,
        paymentAmount: result.rows[0].paymentAmount,
        paymentReference: result.rows[0].paymentReference,
        paymentApprovedAt: result.rows[0].paymentApprovedAt,
        paymentProcessedAt: result.rows[0].paymentProcessedAt
      });

    } catch (error) {
      fastify.log.error('Error fetching payment status:', error);
      return reply.code(500).send({ error: 'Internal server error' });
    }
  });

  /**
   * ROUTE 3: VIEW PAYMENT HISTORY
   * GET /readers/payment-history
   */
  fastify.get('/readers/payment-history', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    try {
      const { pin } = request.user;

      const historyQuery = `
        SELECT 
          ra.id as "assignmentId",
          ra."assignmentNumber",
          ra."paymentStatus",
          ra."paymentAmount",
          ra."paymentReference",
          ra."paymentApprovedAt",
          ra."paymentProcessedAt",
          ra."reportAssignedAt" as "assignedAt",
          ra."correctionsSubmittedAt"
        FROM "readerAssignments" ra
        WHERE ra."readerPin" = $1
        ORDER BY ra."reportAssignedAt" DESC
      `;

      const result = await readersDb.query(historyQuery, [pin]);

      return reply.send({
        success: true,
        payments: result.rows
      });

    } catch (error) {
      fastify.log.error('Error fetching payment history:', error);
      return reply.code(500).send({ error: 'Internal server error' });
    }
  });

  /**
   * ROUTE 4: CONTACT SUPPORT
   * GET /readers/support?assignmentId=xxx&subject=xxx
   */
  fastify.get('/readers/support', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    try {
      const { assignmentId, subject } = request.query;
      const { pin, name, email } = request.user;

      const supportEmail = 'support@qolae.com';
      const emailSubject = subject || 'Payment Inquiry';
      const emailBody = `Reader PIN: ${pin}\nReader Name: ${name}\nReader Email: ${email}\nAssignment ID: ${assignmentId || 'N/A'}`;

      return reply.redirect(`mailto:${supportEmail}?subject=${encodeURIComponent(emailSubject)}&body=${encodeURIComponent(emailBody)}`);

    } catch (error) {
      fastify.log.error('Error accessing support:', error);
      return reply.code(500).send({ error: 'Internal server error' });
    }
  });

}

// ==============================================
// HELPER FUNCTIONS
// ==============================================

/**
 * BUILD TIMELINE
 * Determines which timeline steps are completed/current/pending
 */
function buildTimeline(paymentStatus, assignedAt, paymentApprovedAt, paymentProcessedAt) {
  const timeline = {
    step1: 'pending',
    step2: 'pending',
    step3: 'pending',
    step4: 'pending'
  };

  // Step 1: Report Submitted
  if (assignedAt) {
    timeline.step1 = 'completed';
  }

  // Step 2: Under Review by Liz
  if (paymentStatus === 'pending' && assignedAt) {
    timeline.step2 = 'current';
  } else if (paymentApprovedAt || ['approved', 'processing', 'paid'].includes(paymentStatus)) {
    timeline.step2 = 'completed';
  }

  // Step 3: Payment Processing
  if (paymentStatus === 'approved' || paymentStatus === 'processing') {
    timeline.step3 = 'current';
  } else if (paymentStatus === 'paid') {
    timeline.step3 = 'completed';
  }

  // Step 4: Payment Complete
  if (paymentStatus === 'paid') {
    timeline.step4 = 'completed';
  }

  return timeline;
}
