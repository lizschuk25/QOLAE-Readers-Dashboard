// ==============================================
// READERS DASHBOARD - READER ROUTES
// ==============================================
// Purpose: NDA, Report Viewer, Corrections, Payment Tracking
// Author: Liz
// Date: 28th October 2025
// ==============================================

import pg from 'pg';
import { insertSignaturesIntoNDA, flattenNDA } from '../utils/insertSignaturesIntoReadersNDA.js';

const { Pool } = pg;

// Database connections
const readersDb = new Pool({
  connectionString: process.env.READERS_DATABASE_URL
});

const caseManagersDb = new Pool({
  connectionString: process.env.CASEMANAGERS_DATABASE_URL
});

// ==============================================
// AUTHENTICATION MIDDLEWARE
// ==============================================
async function authenticateReader(request, reply) {
  try {
    await request.jwtVerify();

    // Verify reader role
    if (request.user.role !== 'reader') {
      throw new Error('Unauthorized');
    }
  } catch (error) {
    reply.code(401).send({
      success: false,
      error: 'Authentication required'
    });
  }
}

export default async function readerRoutes(fastify, options) {

  // ==============================================
  // READERS DASHBOARD (Main Workspace)
  // ==============================================
  fastify.get('/readers-dashboard', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name, type } = request.user;

    try {
      // Get reader data
      const readerResult = await readersDb.query(
        `SELECT reader_pin, reader_name, reader_type, email, phone,
                nda_signed, portal_access_status, total_assignments_completed,
                average_turnaround_hours, total_earnings
         FROM readers
         WHERE reader_pin = $1`,
        [pin]
      );

      if (readerResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Reader not found' });
      }

      const reader = readerResult.rows[0];

      // Get active assignments
      const assignmentsResult = await readersDb.query(
        `SELECT assignment_id, assignment_number, report_type,
                assigned_at, deadline, assignment_status, payment_amount
         FROM reader_assignments
         WHERE reader_pin = $1
         AND assignment_status IN ('pending', 'in_progress')
         ORDER BY deadline ASC`,
        [pin]
      );

      return reply.view('readers-dashboard.ejs', {
        reader,
        assignments: assignmentsResult.rows
      });

    } catch (error) {
      fastify.log.error('Error loading readers dashboard:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load dashboard' });
    }
  });

  // ==============================================
  // NDA REVIEW PAGE
  // ==============================================
  fastify.get('/nda-review', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name, type } = request.user;

    try {
      // Get reader data
      const readerResult = await readersDb.query(
        'SELECT reader_pin, reader_name, nda_signed FROM readers WHERE reader_pin = $1',
        [pin]
      );

      if (readerResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Reader not found' });
      }

      const reader = readerResult.rows[0];

      // Get current NDA version
      const ndaResult = await readersDb.query(
        'SELECT version_number, effective_date, nda_content FROM reader_nda_versions WHERE is_current = TRUE'
      );

      return reply.view('nda-review.ejs', {
        reader,
        nda: ndaResult.rows[0]
      });

    } catch (error) {
      fastify.log.error('Error loading NDA review:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load NDA' });
    }
  });

  // ==============================================
  // SIGN NDA (API) - Complete Workflow
  // ==============================================
  fastify.post('/api/readers/sign-nda', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { readerSignature } = request.body;

    try {
      // Get current NDA version
      const ndaResult = await readersDb.query(
        'SELECT id, version_number FROM reader_nda_versions WHERE is_current = TRUE'
      );

      if (ndaResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'NDA version not found' });
      }

      const nda = ndaResult.rows[0];

      // Step 1: Insert signatures (Reader + Liz)
      // Note: NDA was already generated by HR Compliance during reader registration
      const signatureResult = await insertSignaturesIntoNDA(pin, {
        readerSignature: readerSignature,
        lizSignature: true // Liz's signature from file
      });

      if (!signatureResult.success) {
        throw new Error(`Signature insertion failed: ${signatureResult.error}`);
      }

      // Step 2: Flatten NDA (make non-editable)
      const flattenResult = await flattenNDA(pin);
      if (!flattenResult.success) {
        throw new Error(`Flattening failed: ${flattenResult.error}`);
      }

      // Step 3: Update reader - NDA signed
      await readersDb.query(
        `UPDATE readers
         SET nda_signed = TRUE,
             nda_signed_at = NOW(),
             nda_version_id = $1,
             portal_access_status = 'active'
         WHERE reader_pin = $2`,
        [nda.id, pin]
      );

      // Log activity
      await readersDb.query(
        `INSERT INTO reader_activity_log (reader_pin, activity_type, activity_description, performed_by)
         VALUES ($1, $2, $3, $4)`,
        [pin, 'nda_signed', `Reader signed NDA version ${nda.version_number}`, name]
      );

      return reply.send({
        success: true,
        message: 'NDA signed successfully',
        redirectTo: '/readers-dashboard',
        ndaPath: flattenResult.outputPath
      });

    } catch (error) {
      fastify.log.error('Error signing NDA:', error);
      return reply.code(500).send({ success: false, error: 'Failed to sign NDA' });
    }
  });

  // ==============================================
  // REPORT VIEWER (In-Workspace Only - No Download)
  // ==============================================
  fastify.get('/report-viewer/:assignmentId', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { assignmentId } = request.params;

    try {
      // Get assignment details
      const assignmentResult = await readersDb.query(
        `SELECT assignment_id, assignment_number, reader_pin, report_type,
                assignment_status, redacted_report_path, deadline
         FROM reader_assignments
         WHERE assignment_id = $1 AND reader_pin = $2`,
        [assignmentId, pin]
      );

      if (assignmentResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Assignment not found' });
      }

      const assignment = assignmentResult.rows[0];

      // Check if assignment is accessible
      if (assignment.assignment_status === 'completed' || assignment.assignment_status === 'cancelled') {
        return reply.code(403).send({ success: false, error: 'This assignment is no longer accessible' });
      }

      return reply.view('report-viewer.ejs', {
        assignment,
        reader: { pin, name }
      });

    } catch (error) {
      fastify.log.error('Error loading report viewer:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load report' });
    }
  });

  // ==============================================
  // CORRECTIONS EDITOR (In-Workspace Only)
  // ==============================================
  fastify.get('/corrections-editor/:assignmentId', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { assignmentId } = request.params;

    try {
      // Get assignment details
      const assignmentResult = await readersDb.query(
        `SELECT assignment_id, assignment_number, reader_pin, report_type,
                assignment_status, redacted_report_path, corrections_content,
                deadline
         FROM reader_assignments
         WHERE assignment_id = $1 AND reader_pin = $2`,
        [assignmentId, pin]
      );

      if (assignmentResult.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Assignment not found' });
      }

      const assignment = assignmentResult.rows[0];

      return reply.view('corrections-editor.ejs', {
        assignment,
        reader: { pin, name }
      });

    } catch (error) {
      fastify.log.error('Error loading corrections editor:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load editor' });
    }
  });

  // ==============================================
  // SAVE CORRECTIONS (API)
  // ==============================================
  fastify.post('/api/readers/save-corrections', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { assignmentId, corrections } = request.body;

    try {
      // Update assignment with corrections
      await readersDb.query(
        `UPDATE reader_assignments
         SET corrections_content = $1,
             corrections_updated_at = NOW()
         WHERE assignment_id = $2 AND reader_pin = $3`,
        [JSON.stringify(corrections), assignmentId, pin]
      );

      // Log activity
      await readersDb.query(
        `INSERT INTO reader_activity_log (reader_pin, activity_type, activity_description, performed_by)
         VALUES ($1, $2, $3, $4)`,
        [pin, 'corrections_saved', `Reader saved corrections for assignment ${assignmentId}`, name]
      );

      return reply.send({
        success: true,
        message: 'Corrections saved successfully'
      });

    } catch (error) {
      fastify.log.error('Error saving corrections:', error);
      return reply.code(500).send({ success: false, error: 'Failed to save corrections' });
    }
  });

  // ==============================================
  // SUBMIT CORRECTIONS (API)
  // ==============================================
  fastify.post('/api/readers/submit-corrections', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;
    const { assignmentId } = request.body;

    try {
      // Update assignment status
      const result = await readersDb.query(
        `UPDATE reader_assignments
         SET assignment_status = 'completed',
             corrections_submitted_at = NOW(),
             actual_turnaround_hours = EXTRACT(EPOCH FROM (NOW() - assigned_at)) / 3600
         WHERE assignment_id = $1 AND reader_pin = $2
         RETURNING payment_amount`,
        [assignmentId, pin]
      );

      if (result.rows.length === 0) {
        return reply.code(404).send({ success: false, error: 'Assignment not found' });
      }

      // Update reader stats
      await readersDb.query(
        `UPDATE readers
         SET total_assignments_completed = total_assignments_completed + 1
         WHERE reader_pin = $1`,
        [pin]
      );

      // Log activity
      await readersDb.query(
        `INSERT INTO reader_activity_log (reader_pin, activity_type, activity_description, performed_by)
         VALUES ($1, $2, $3, $4)`,
        [pin, 'corrections_submitted', `Reader submitted corrections for assignment ${assignmentId}`, name]
      );

      return reply.send({
        success: true,
        message: 'Corrections submitted successfully! Payment pending review.',
        paymentAmount: result.rows[0].payment_amount
      });

    } catch (error) {
      fastify.log.error('Error submitting corrections:', error);
      return reply.code(500).send({ success: false, error: 'Failed to submit corrections' });
    }
  });

  // ==============================================
  // PAYMENT STATUS
  // ==============================================
  fastify.get('/payment-status', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    const { pin, name } = request.user;

    try {
      // Get payment history
      const paymentsResult = await readersDb.query(
        `SELECT assignment_id, assignment_number, payment_amount,
                corrections_submitted_at, corrections_approved,
                payment_approved, payment_approved_at, payment_processed_at
         FROM reader_assignments
         WHERE reader_pin = $1
         AND assignment_status = 'completed'
         ORDER BY corrections_submitted_at DESC`,
        [pin]
      );

      // Get total earnings
      const earningsResult = await readersDb.query(
        'SELECT total_earnings FROM readers WHERE reader_pin = $1',
        [pin]
      );

      return reply.view('payment-status.ejs', {
        reader: { pin, name, totalEarnings: earningsResult.rows[0].total_earnings },
        payments: paymentsResult.rows
      });

    } catch (error) {
      fastify.log.error('Error loading payment status:', error);
      return reply.code(500).send({ success: false, error: 'Failed to load payment status' });
    }
  });

  // ==============================================
  // PAYMENT PROCESSING ROUTES
  // ==============================================
  // Author: Liz
  // Date: October 28, 2025
  // Purpose: Payment modal, status API, history, support
  // ==============================================

  /**
   * ROUTE 1: RENDER PAYMENT PROCESSING MODAL
   * GET /payment-processing?assignmentId=xxx
   */
  fastify.get('/payment-processing', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    try {
      const { assignmentId } = request.query;
      const { pin } = request.user;

      if (!assignmentId) {
        return reply.code(400).send({ error: 'Assignment ID is required' });
      }

      // Get payment data from qolae_readers
      const paymentQuery = `
        SELECT 
          ra.id as assignment_id,
          ra.reader_pin,
          ra.payment_status,
          ra.payment_amount,
          ra.payment_reference,
          ra.payment_approved_at,
          ra.payment_processed_at,
          ra.report_assigned_at as assigned_at,
          ra.corrections_submitted_at,
          r.reader_name,
          r.email as reader_email,
          r.payment_rate,
          r.reader_type
        FROM reader_assignments ra
        INNER JOIN readers r ON ra.reader_pin = r.reader_pin
        WHERE ra.id = $1 AND ra.reader_pin = $2
      `;

      const result = await readersDb.query(paymentQuery, [assignmentId, pin]);

      if (result.rows.length === 0) {
        return reply.code(404).send({ error: 'Payment record not found' });
      }

      const paymentData = result.rows[0];

      // Get banking details from qolae_hrcompliance (via separate connection)
      // NOTE: For now, we'll handle this separately. Banking details should be
      // fetched from HR Compliance database when needed for actual payment processing.
      
      // Build timeline based on payment status
      const timeline = buildTimeline(
        paymentData.payment_status,
        paymentData.assigned_at,
        paymentData.payment_approved_at,
        paymentData.payment_processed_at
      );

      // Determine reader type
      const readerType = paymentData.reader_type === 'first_reader' ? 'first' : 'second';

      // Render EJS template
      return reply.view('paymentProcessing.ejs', {
        // Assignment info
        assignmentId: paymentData.assignment_id,
        readerPin: paymentData.reader_pin,
        
        // Reader info
        readerName: paymentData.reader_name,
        readerEmail: paymentData.reader_email,
        readerType: readerType,
        
        // Payment status & amount
        paymentStatus: paymentData.payment_status || 'pending',
        paymentAmount: paymentData.payment_amount || paymentData.payment_rate,
        paymentReference: paymentData.payment_reference || 'N/A',
        
        // Timeline dates
        assignedAt: paymentData.assigned_at,
        correctionsSubmittedAt: paymentData.corrections_submitted_at,
        paymentApprovedAt: paymentData.payment_approved_at,
        paymentProcessedAt: paymentData.payment_processed_at,
        
        // Timeline status
        timeline: timeline,
        
        // Placeholder banking details (will be fetched from HR Compliance when needed)
        bankName: 'Not loaded',
        accountHolderName: 'Not loaded',
        lastFourDigits: '****',
        sortCode: 'N/A',
        accountType: 'unknown',
        paymentDetailsVerified: false
      });

    } catch (error) {
      fastify.log.error('Error rendering payment processing modal:', error);
      return reply.code(500).send({ error: 'Internal server error' });
    }
  });

  /**
   * ROUTE 2: GET PAYMENT STATUS (API - FOR AUTO-REFRESH)
   * GET /api/readers/payment/status/:assignmentId
   */
  fastify.get('/api/readers/payment/status/:assignmentId', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    try {
      const { assignmentId } = request.params;
      const { pin } = request.user;

      const statusQuery = `
        SELECT 
          payment_status,
          payment_amount,
          payment_reference,
          payment_approved_at,
          payment_processed_at
        FROM reader_assignments
        WHERE id = $1 AND reader_pin = $2
      `;

      const result = await readersDb.query(statusQuery, [assignmentId, pin]);

      if (result.rows.length === 0) {
        return reply.code(404).send({ error: 'Assignment not found' });
      }

      return reply.send({
        paymentStatus: result.rows[0].payment_status,
        paymentAmount: result.rows[0].payment_amount,
        paymentReference: result.rows[0].payment_reference,
        paymentApprovedAt: result.rows[0].payment_approved_at,
        paymentProcessedAt: result.rows[0].payment_processed_at
      });

    } catch (error) {
      fastify.log.error('Error fetching payment status:', error);
      return reply.code(500).send({ error: 'Internal server error' });
    }
  });

  /**
   * ROUTE 3: VIEW PAYMENT HISTORY
   * GET /readers/payment-history
   */
  fastify.get('/readers/payment-history', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    try {
      const { pin } = request.user;

      const historyQuery = `
        SELECT 
          ra.id as assignment_id,
          ra.assignment_number,
          ra.payment_status,
          ra.payment_amount,
          ra.payment_reference,
          ra.payment_approved_at,
          ra.payment_processed_at,
          ra.report_assigned_at as assigned_at,
          ra.corrections_submitted_at
        FROM reader_assignments ra
        WHERE ra.reader_pin = $1
        ORDER BY ra.report_assigned_at DESC
      `;

      const result = await readersDb.query(historyQuery, [pin]);

      return reply.send({
        success: true,
        payments: result.rows
      });

    } catch (error) {
      fastify.log.error('Error fetching payment history:', error);
      return reply.code(500).send({ error: 'Internal server error' });
    }
  });

  /**
   * ROUTE 4: CONTACT SUPPORT
   * GET /readers/support?assignmentId=xxx&subject=xxx
   */
  fastify.get('/readers/support', {
    preHandler: authenticateReader
  }, async (request, reply) => {
    try {
      const { assignmentId, subject } = request.query;
      const { pin, name, email } = request.user;

      const supportEmail = 'support@qolae.com';
      const emailSubject = subject || 'Payment Inquiry';
      const emailBody = `Reader PIN: ${pin}\nReader Name: ${name}\nReader Email: ${email}\nAssignment ID: ${assignmentId || 'N/A'}`;

      return reply.redirect(`mailto:${supportEmail}?subject=${encodeURIComponent(emailSubject)}&body=${encodeURIComponent(emailBody)}`);

    } catch (error) {
      fastify.log.error('Error accessing support:', error);
      return reply.code(500).send({ error: 'Internal server error' });
    }
  });

}

// ==============================================
// HELPER FUNCTIONS
// ==============================================

/**
 * BUILD TIMELINE
 * Determines which timeline steps are completed/current/pending
 */
function buildTimeline(paymentStatus, assignedAt, paymentApprovedAt, paymentProcessedAt) {
  const timeline = {
    step1: 'pending',
    step2: 'pending',
    step3: 'pending',
    step4: 'pending'
  };

  // Step 1: Report Submitted
  if (assignedAt) {
    timeline.step1 = 'completed';
  }

  // Step 2: Under Review by Liz
  if (paymentStatus === 'pending' && assignedAt) {
    timeline.step2 = 'current';
  } else if (paymentApprovedAt || ['approved', 'processing', 'paid'].includes(paymentStatus)) {
    timeline.step2 = 'completed';
  }

  // Step 3: Payment Processing
  if (paymentStatus === 'approved' || paymentStatus === 'processing') {
    timeline.step3 = 'current';
  } else if (paymentStatus === 'paid') {
    timeline.step3 = 'completed';
  }

  // Step 4: Payment Complete
  if (paymentStatus === 'paid') {
    timeline.step4 = 'completed';
  }

  return timeline;
}
